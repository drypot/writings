---
title: What Makes Scala Scalable?
---

2011-07-07 18:54


### What Makes Scala Scalable? / 스칼라는 어떻게 확장성을 갖는가?

스칼라에서 확장성을 이야기할 때는
문법의 세부사항들로부터 콤포넌트 추상화에 이르기까지 많은 요소의 확장성에 대해 이야기할 수 있는데
그중 가장 중요한 것은 OOP 와 FP 의 결합이라 할 수 있다.

스칼라는 OOP 와 FP 를 하나의 통합된 언어에 융합하는데 있어서 다른 대중적인 언어들보다 한 발짝 앞서 있다.
다른 언어들은 오브젝트와 펑션을 두 개의 다른 개념으로 보지만, 스칼라에서는 펑션값을 오브젝트로 취급한다.
학문적인 꼼꼼함일 뿐이라 생각할 수도 있겠지만 이는 확장성을 위한 깊은 숙고의 결과다.
앞에서 본 액터 컨셉은 펑션과 오브젝트의 통합이 없었다면 구현되지 못했을 것이다.
이 절에서는 스칼라가  OO 와 F 개념을 어떻게 결합하는지 그 개요를 보게 된다.


### Scala is object-oriented / 스칼라는 객체지향적이다

OOP 는 엄청나게 성공했다.
60 년대 중반 Simula, 70 년대 Smalltalk 로 부터 출발하여 이제는 OOP 를 채용하지 않는 언어가 없을 정도다.
어떤 영역은 오브젝트가 완전히 점령했다.
OO 에 대한 엄밀한 정의는 없지만 OO 가 무엇인지에 대한 공감은 확실히 있다.

OOP 의 동기는 아주 단순하다.
아주 사소한 프로그램들을 제외하고는 모두 어떤 식의 구조가 필요하다는 것이다.
구조를 만들기 위한 가장 단순한 방법은 데이타와 연산들을 어떤 식의 컨테이너에 집어넣는 것이다.
OOP 의 위대한 아이디어는 데이터와 연산들을 함께 넣을 수 있도록 이 컨테이너들을 일반화시키고,
다른 컨테이너에 저장하거나 연산 인자로 전달할 수 있도록 컨테이너 자체를 값으로 만든 것이다.
이 컨테이너들을 오브젝트 라 부른다.

Smalltalk 를 발명한 Alan Kay 는 최대로 단순화된 오브젝트는 완전한 컴퓨터와 같은 제작 원리를 가진다고 말했다.
여기서 원리란 데이터와 연산을 형식화된 인터페이스 아래에서 결합하는 것이다.

Smalltalk 는 논리연산의 결과에까지 이 원리를 밀어붙였다.
하지만 OOP 가 오랜 시간동안 주류였음에도 Smalltalk 이후 철저히 OO 개념을 지켰던 언어는 거의 없었다.
예를 들어 많은 언어들은 자바의 원시 값처럼 오브젝트가 아닌 값들을 수용하고 있다.
또 어떤 오브젝트의 멤버도 아닌 정적(static) 필드와 메서드들을 허용하고 있다.

처음에는 무해해 보일지라도 순수한 OOP 아이디어에서 벗어나는 이런 일탈들은
확장성을 방해하거나 일을 복잡하고 귀찮게 만드는 경향을 갖는다.

반대로 스칼라는 순수한 형태의 OO 언어이다.
모든 값은 오브젝트이고 모든 연산은 메서드 콜이다.
1 + 2 는 Int 클래스에 정의된 + 메서드를 호출한다는 의미다.
연산자처럼 보이는 메서드를 정의할 수 있다.
이것이 액터에서 requester ! sum 과 같은 표현을 사용할 수 있었던 이유다.
! 은 액터 클래스의 메서드이다.

컴파일 초기 단계에선 + 연산자를 해석할 때 Int 클래스의 + 메서드를 호출하는 중간 코드를 만들지만,
옵티마이징 단계에서 Int 클래스 메서드 호출들을 JVM 정수 연산 코드로 모두 교체하므로 성능상 불이익은 없다.
일반 스크립트 언어는 단순 연산에도 메서드 호출을 사용해서 성능 손실이 심하지만 스칼라는 그런 문제를 가지지 않는다.

스칼라는 오브젝트를 조합(composing)하는 데 있어 다른 언어들보다 앞서있다.
스칼라 트레잇(trait)이 예다.

특성, 즉 트레잇(trait)은 자바의 인터페이스와 비슷하지만 메서드 구현을 가질 수 있고 필드 또한 가질 수 있다.
클래스 멤버들에 트레잇의 멤버들을 추가하는 믹싱 (mixin composition) 방식으로 오브젝트를 만들 수 있다.
클래스의 서로 다른 측면들을 서로 다른 트레잇에 격리해 둘 수 있다.

트레잇은 인터페이스와 비슷하지만 인터페이스의 고질적인 문제를 해결한다.
인터페이스에는 코드를 넣어 놓을 수가 없기 때문에 인터페이스의 메서드들을 서로 다른 클래스에서 반복 구현해야한다.
특히 컨테이너 라이브러리의 경우 클래스별로 한 두 메서드만 다르게 구현할 뿐 나머지 수십 개 매서드는 같은 경우가 많다.
이럴 때 공통되는 메서드를 트레잇에 올려놓으면 클래스에서 메서드를 반복해 구현할 필요가 없다.

트레잇은 JVM 에겐 인터페이스로 보인다. JVM 의 인터페이스에는 코드가 존재할 수 없다.
트레잇에 구현해 놓은 메서드는 스칼라 컴파일러가 트레잇을 사용한 클래스를 컴파일 할 때 클래스에 구현해 넣는다.
스카라가 트레잇의 메서드를 클래스로 그대로 옮겨줄 뿐이지만 이것만으로도 클래스 트리 구성이 매우 편해진다.

트레잇과 믹싱이 다중 상속처럼 보일 수 있겠다. 하지만 세부 모습에 있어서는 다르다.
트레잇은 클래스와 다르게 아무 클래스에나 기능을 추가할 수 있다.
클래스 보다 여기 저기 꼽아쓰기 쉽다는 말이다.
또 같은 클래스가 서로 다른 경로를 통해 상속되는 다중 상속의 전통적인 다이아몬드 상속문제를 피해간다.


### Scala is functional / 스카라는 함수형 언어이기도 하다

스칼라는 순수한 OO 언어이기도 하지만 F 언어로서도 무르익었다.
FP 아이디어는 (전기) 컴퓨터보다 더 오래 되었다.
FP 의 기초는 1930 년대에 개발된 Alonzo Church 의 lambda (람다) calculus 에서 만들어 졌다.
최초의 FP 언어는 1950 년대에 시작된 Lisp 였다.
인기를 얻은 다른 F 언어들은 Scheme, SML, Erlang, Haskell, OCaml, F# 등이 있다.
FP 는 학계에선 잘 알려져 있었으나 오랫동안 다소 변두리에 있었고 산업에선 널리 쓰이지 않았다.
하지만 요즘에는 FP 언어와 테크닉에 대한 관심이 높아지는 것을 볼 수 있다.

FP 는 두 가지 주요 아이디어를 가지고 설명할 수 있다.

첫 번째는 펑션이 값이라는 것이다.

F 언어에서는 펑션이 정수나 문자열과 비슷한 성격을 갖는 값이다.
펑션을 다른 펑션의 인자로 전달할 수 있고, 펑션의 결과로 펑션을 돌려받을 수 있고, 펑션을 변수에 저장할 수 있다.
이름을 붙이지 않은 상태로 펑션을 정의할 수도 있다.

값으로의 펑션을 사용해 연산을 추상화하거나 새로운 컨트롤 구문을 편리하게 만들 수 있다.
펑션을 값으로 사용할 수 있으면 뛰어난 표현성을 제공하기 때문에 읽기 쉽고 간결한 프로그램을 만들 수 있다.
이것은 확장성을 위해서도 중요한 역할을 한다.
예를 들어 이전에 보았던 액터 예제의 receive 구문은 펑션을 인자로 받는 메서드 호출이다.
receive 구문 안에 있는 코드는 있는 그대로 receive 메서드에 전달되는 펑션 리터럴이다.

펑션은 전통적인 대부분의 언어에서 값이 아니다.
펑션을 값으로 처리하는 언어일 지라도 펑션을 이 등급으로 좌천시키는 경우가 있다.
예로 C 와 C++ 의 펑션 포인터는 펑션이 아닌 다른 값들과 다른 성격을 갖는다.
C 와 C++ 에서는 펑션 포인터가 전역 펑션만 참조할 수 있다.
펑션 내부의 값들을 참조하는 중첩된 펑션 정의를 허용하지 않는다.
이름을 갖지 않는 펑션 리터럴을 정의할 수도 없다.

FP 의 두 번째 주요 아이디어는 프로그램이 데이터 자체에 변경을 가하는 것이 아니라
입력 값을 출력 값으로 매핑하기만 한다는 것이다.

이 차이를 이해하기 위해 루비와 자바의 스트링 구현을 보자.
루비에서 스트링은 문자의 배열이다.
스트링 안의 문자는 개별적으로 변경될 수 있다.
문자열 안의 세미콜론을 마침표로 변경할 수 있다.

자바와와 스칼라에서의 스트링은 이와 다르게 수학적 의미의 문자 수열이다.
s.replace(';', '.') 과 같은 표현을 사용해 스트링의 문자를 변경하면 s 와는 다른 새로운 스트링이 만들어진다.
이를 다르게 표현하면 자바의 스트링은 변경 불가능(immutable)하고, 로비의의 스트링은 변경 가능(mutable)하다고 말한다.
스트링에서만 본다면 자바는 F 언어이고 루비는 그렇지 않다.
변경 불가능한 데이터 구조는 FP 의 기본 토대가 된다.

스칼라 라이브러리는 많은 변경 불가능한 데이터 타입들을 정의해 두고 있다.
예를 들어 immutable list, tuple, map, set 등을 가지고 있다.

FP 의 두 번째 아이디어를 다르게 표현하면 메서드는 사이드 이펙트(side effect)를 가지면 안 된다는 것이다.
메서드는 인자를 받고 결과를 리턴하는 것으로만 외부와 통신해야 한다.
예를 들어, 자바 String 클래스의 replace 메서드는 이 설명에 부합한다.
이 메서드는 두 문자를 받아서 한 문자가 다른 한 문자로 전부 치환된 새로운 문자열을 생성한다.
replace 를 호출할 때 다른 효과는 나타나지 않는다.
replace 같은 메서드를 referentially transparent 하다고 한다.
모든 입력에 대해 메서드 호출은 프로그램의 문맥에 영향을 미치지 않고 그 결과로 치환될 수 있다는 의미다.

F 언어들은 변하지 않는 데이터 스트럭쳐와 referentially transparent 한 메서드를 장려한다.
몇몇 F 언어들은 이를 철처히 요구한다.
스칼라는 사용자에게 선택권을 준다.
원할 경우 절차적인 (imperative) 스타일로 프로그래밍할 수 있다.
절차적 스타일이란 변경 가능한 데이터와 사이드 이펙트를 용인하는 프로그래밍 스타일을 말한다.
하지만 스칼라에는 좋은 F 적 대안들이 있기 때문에 쉽게 절차적인 구문을 피할 수 있다.

### 참고 1

순수 FP 에서는 변경 불가능한 데이터를 좋아할 뿐만 아니라 변수란 개념 자체를 혐오한다.
이런 관점에서 스칼라는 FP 로부터는 사실 꽤 거리가 있다.
구체적으로 말하면 스칼라는 클래스와 메서드 명세 차원에서는 F 적일 수 있지만,
메서드 내부 구현에서는 F 적인 방식보다 절차적(procedural, imperative)인 방법을 더 많이 사용한다.
현실적으로 F 적인 방식보다 절차적인 변수 + 루프 조합이 더 효율적이기도 하다. =,=

### 참고 2

referentially transparency 를 깨는 방법은 쉽다.
전역 변수를 쓰면 된다.
아니면 디스크나 네트웍 IO 를 삽입하는 것도 좋겠다.


{:class="go-to-index"}
[Programming in Scala](index)
