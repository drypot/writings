---
title: Scala Is Statically Typed
---

2011-07-08 21:08

(번역하면서 삽입한 원전에 없던 문장은 앞으로 괄호로 묶어 놓겠습니다.)

### Scala is statically typed / 스칼라는 정적 타입 언어다

정적 타입 시스템(static type system)에서는 값의 종류, 즉 타입에 따라 변수와 수식을 분류한다.
(기본적으로 변수와 타입이 다른 값은 변수에 대입할 수 없다.)

스칼라는 매우 고도화된 정적 타입 시스템을 가진 언어다.
자바와 매우 흡사한 중첩 클래스 타입 시스템을 가지고 있다.
제네릭(generic)을 통해 인자를 가진 타입을 만들 수 있다.
인터섹션(intersection)으로 타입들을 결합할 수 있다.
추상타입(abstract type)을 통해 타입의 세세한 면을 감출 수 있다.
이들이 타입을 구성하는데 튼튼한 기초를 제공하기 때문에
안전하면서도 유연한 인터페이스를 디자인할 수 있다.
(C++ 에서는 abstract method 를 가진 클래스를 추상 클래스라 칭하는데 스칼라에서 추상타입은 의미가 다르니 주의하자.)

Perl, Python, Ruby, Groovy 같은 동적 타입 언어들을 좋아한다면
정적 타입 시스템이 스칼라의 강점이라는 주장을 의아하게 생각할 수 있다.
타입 시스템에 구애 받지 않는 것이 동적 타입 언어의 주요한 잇점이라 들어왔기 때문일 것이다.

정적 타입 시스템에 반대하는 가장 일반적인 논거는 다음과 같다.
정적 타입 시스템은 프로그램을 너무 장황하게 만든다.
프로그래머들이 자신의 생각을 자신이 원하는 방식대로 표현하지 못하게 한다.
시스템을 동적으로 수정하는 패턴을 사용할 수 없다. 등.

하지만, 이런 주장은 장황하고 융통성 없는 특정 타입 시스템에 대한 불만이기 일쑤다. (자바를 말하는 것이다. =,=)
즉, 정적 타입 일반 개념에 대한 비판이라고 받아들이기에는 무리가 있다.

이에 대해 스몰토크를 만든 Alan Kay 는 다음과 같이 말했다.
"나는 타입에 부정적이지 않다. 아직 극심한 고통을 수반하지 않는 정적 타입 시스템을 발견하지 못했기 때문에 동적 타이핑을 좋아할 뿐이다."

이 책을 통해 스칼라 타입 시스템이 "극심한 고통"과는 거리가 멀다는 사실을 확신시키고자 한다.
실제로 스칼라는 흔히 볼 수 있는 정적 타이핑의 두 가지 고민거리를 우아하게 해결했다.
타입 추론(type inference)을 통해 장황함을 제거하고 패턴 매칭과 타입을 정의하고 결합하는 새로운 방식들을 통해 유연성을 가진다.

이런 장애들을 없앰으로서 스칼라에서는 정적 타입 시스템이 가진 전통적인 잇점들을 제대로 평가할 수 있다.
추상화된 프로그램 요소들의 속성을 검증할 수 있고, 안전하게 리펙터링 할 수 있고, 문서화도 유리하다.


### Verifiable properties / 여러 요인들을 점검할 수 있다.

정적 타입 시스템은 특정 종류의 런타임 에러가 없다는 것을 확인할 수 있게 해준다.
예를 들어 논리값은 정수에 더할 수 없다라든가,
비공개 변수는 클래스 외부에서 접근할 수 없다라든가,
펑션은 정확한 수의 인자에만 적용할 수 있다라든가,
문자열 집합에는 문자열만 추가할 수 있다라든가 등을 코드 실행전에 확인할 수 있다.

안타깝게도 다른 종류의 에러들은 현재의 정적 타입 시스템으로는 확인할 수가 없다.
예를 들어 종료 지점이 없는 펑션이라든가, 배열 경계값 위반이라든가, 0 으로 나누기 같은 것들.
프로그램이 명세를 정확히 따르는지도 확인할 수가 없다.

그래서 정적 타입 시스템을 별로 유용하지 않은 것으로 각하시켜 버리는 사람들도 있다.
단순한 오류만 찾아낼 수 있는 타입 시스템 대신, 요즘은 보다 확장된 검사 작업을 할 수 있는 유닛 테스팅을 많이 사용하고 있기 때문이다.

확실히 정적 타입 시스템이 유닛 테스팅을 대신할 수는 없다.
하지만 유닛 테스트의 수를 줄일 수는 있다.

더 나아가 보면 정적 타입 시스템이 유닛 테스팅을 대신할 수 없듯이
유닛 테스팅 또한 정적 타이핑을 대신할 수 없다.

Edsger Dijkstra 가 말했다.
테스팅은 오류가 있음을 확인할 수가 있을 뿐, 오류가 없음을 증명하진 못한다.

정적 타이핑을 통해 얻는 보장이 간단한 것처럼 보일진 모르겠지만
유닛 테스팅을 가지고서는 정적 타입 시스템이 컴파일 과정에서 제공하는 형태의 확실한 보장은 얻지 못한다.


### Safe refactorings / 안전한 리펙터링

정적 타입 시스템에서는 코드 베이스가한 변경 결과에 높은 신뢰성을 가질 수 있다.
메서드에 추가 인자를 더하는 리펙터링을 생각해보자.
정적 타입 언어에서는 수정을 하고, 재컴파일을 하고, 타입 에러의 원인이 되는 행들을 간단히 확인하고 고칠 수 있다.
메서드 이름을 변경한다든지, 이 클래스에서 저 클래스로 메서드를 옮긴다든지 하는 다른 간단한 리펙터링 작업에서도 비슷한 잇점을 기대할 수 있다.


### Documentation / 문서화

정적 타입들은 컴파일러가 정확성을 보장하는 문서 기능을 할 수 있다.
일반 주석은 코드를 변경하면서 주석을 같이 수정하지 않으면 실제 코드 내용과 괴리가 발생할 수 있지만
타입 정보는 최근에 컴파일러만 정상 통과하였다면 그럴 일이 없다.

더 나아가 컴파일러와 개발환경은 타입 정보를 이용해서 향상된 문맥 도움말을 제공하기도 한다.
IDE 는 수식의 정적 타입을 확인하고 해당 타입이 가진 모든 멤버들을 확인해서 적용 가능한 모든 멤버를 표시할 수 있다.

정적 타입이 프로그램 문서화에 유용할지라도 이것이 프로그램을 난잡하게 만든다면 매우 성가실 것이다..

    def f(x: String) = ...

위 메서드 정의에서 f 의 인자가 String 이어야한다는 것은 유용한 정보다.
하지만, 아래 예에서 두 타입 설명중 최소한 하나는 불필요해 보인다.

    val x: HashMap[Int, String] = new HashMap[Int, String]()

x 는 Int 를 키로 갖고 String 을 값으로 갖는 HashMap 이다라는 사실은 한 번만 말하면 되는 것이다.
똑 같은 구절을 두 번 반복할 필요는 없다.

스칼라는 매우 정교한 타입 추론 시스템을 가지고 있어서 귀찮다고 생각할 수 있는 거의 모든 타입 정보를 생락할 수 있다.
아래에 위의 구문와 같은 기능을 하는 두 예가 나와 있다.

    val x = new HashMap[Int, String]()
    val x: Map[Int, String] = new HashMap()

스칼라에서는 구체적인 타입이 전혀 없는 코드들을 쉽게 만날 수 있다.
동적 타입 스크립트 언어로 쓴 것 같아 보이기도 한다.
미리 준비된 라이브러리 콤포넌트를 연결하는 코드에서는 특히 그렇다.

반대로 라이브러리 콤포넌트 자체에 대해서는 이 현상이 덜한데
유연한 사용 패턴을 가능하게 하기 위해 매우 정교하게 타입들을 사용하기 때문이다.
재사용 가능한 콤포넌트의 인터페이스를 구성하는 멤버들의 타입 특성은 명시적으로 적어야 한다.
이 타입 특성들이 콤포넌트와 클라이언트간 계약의 필수적인 부분을 구성하기 때문이다.


{:class="go-to-index"}
[Programming in Scala](index)
