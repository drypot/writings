# Scala's Root

2011-07-08 21:54


### Scala's Root / 스칼라의 뿌리

스칼라의 디자인은 많은 프로그래밍 언어들과 관련 아이디어들로부터 영향을 받았다.
사실 스칼라의 기능중 단지 몇 가지만이 새로운 것이다.
대부분의 기능은 이미 어떤 식으로든 다른 언어에 구현되어 있다.
스칼라의 혁신적인 부분은 주로 이런 구성 요소들을 어떻게 한자리에 모아 놓았는가에서 찾을 수 있다.
이번 섹션에는 스칼라 디자인에 영향을 미친 중요한 점들을 나열하였다.
이 목록은 완전하진 않다.
프로그래밍 언어 디자인 영역에는 똑똑한 아이디어들이 너무 많아서 한꺼번에 모두를 열거하는 것은 어려운 일이다.

겉모습에서 보면 스칼라는 자바와 C#의 문법중 많은 부분을 차용하였다.
더 올라가 자바와 C#은 C 와 C++ 로 부터 대부분의 문법적 관례들을 가져왔다.
수식, 문장, 블럭들은 자바와 비슷하다. 클래스 문법과 package, import 관련 문법도 그렇다.
문법 외에도 원시 타입, 클래스 라이브러리, 실행 모델과 같은 자바의 다른 요소들도 받아들였다.

스칼라는 다른 언어들에게도 큰 빚을 졌다.
스칼라의 일관적인 오브젝트 모델은 스몰토크로부터 개척되었고 이후 루비를 통해 계승되었다.
스칼라의 구문들은 거의 모든 경우에 있어서 다른 구문 안에 중첩될 수 있는데 이런 아이디어는 Algol, Simula, Beta, gbeta 등에 존재한다.
메서드 호출과 필드 선택을 동일한 형식으로 적는 것은 Eiffel 로 부터 왔다.
펑셔널 프로그래밍에 대한 접근은 SML, OCaml, F# 등과 같은 ML 계열 언어들과 사상을 공유한다.
스칼라 기본 라이브러리의 고계도 함수(higher-order function, 쉽게 말해 펑션을 인자로 받는 펑션)들은 ML 이나 Haskell 에 존재한다.
스칼라의 기본 인자값은 Haskell 의 타입 클래스가 동기가 되었다.
Haskell 은 보다 전통적인 OO 설정을 가지고 같은 결과를 얻는다.
액터 기반 동시처리 라이브러리는 Erlang 으로부터 강한 영감을 받았다.

스칼라가 내외부적인 확장에 관심을 보인 첫 언어는 아니다.
여러 응용영역에 걸쳐 논의 할 수 있을 확장적 언어에 대한 역사적 뿌리는 Peter Landin 의 1966 년 논문 "The Next 700 Programming Languages." 에 있다.
이 논문에 묘사된 Iswim 이란 언어는 Lisp 와 함께 펑셔널 언어의 개척자로 꼽힌다.
이항 연산자(infix operator)를  펑션으로 다룰 수 있다는 독특한 아이디어는 Iswim 과 Smalltalk 로 부터 유래한다.
또 하나의 중요한 아이디어는 펑션 리터럴이나 블럭을 인자에 허용하는 것이다.
펑션 리터럴을 통해 라이브러리화된 컨트롤 구조를 사용할 수 있다.
이 아이디어 또한 Iswim 와 Smalltalk 로부터 온다.
Smalltalk 와 Lisp 는 유연한 문법을 가지고 있어서 내부적으로 사용되는 DSL(domain-specific langauge) 구축에 집중적으로 사용되었다.
C++ 도 오퍼레이터 오버로딩과 템플릿 시스템을 통해 확장하고 최적화해 사용 수 있는 또 다른 언어다.
스칼라와 비교하면 C++ 은 좀더 저수준의 시스템 지향적인 코어위에 만들어 졌다.

스칼라가 FP 와 OOP 를 통합하는 분야에서 가장 진보해 있기는 하지만 처음으로 이러한 시도를 한 것은 아니다.
FP 와 OOP 를 부분적으로 통합한 언어들로는 루비, 스몰토크, 파이선 등이 있다.
자바 플랫폼에서는 Pizza, Nice, Multi-Java 등이 자바와 비슷한 코어를 펑셔널 아이디어로 확장했다.
또한 OCaml, F#, PLT-Scheme 등 F 언어 입장에서 오브젝트 시스템을 받아들인 경우도 있다.

스칼라는 몇 가지 혁신을 통해 프로그래밍 언어 분야에 기여하기도 했다.
예를 들어 추상 타입은 generic 타입에 비해 보다 OO 적인 대안이다.
(다른 글에도 적었지만 스칼라의 추상 타입은 C++ 의 추상 클래스와 개념이 다르다.)
트레잇은 유연한 콤포넌트 조합을 가능하게 한다.
익스트랙터(extractor)는 패턴 매칭에 표현 독립적인 방법을 제공한다. (이게 무슨 말인지는 한참 후에 =,=)
이 혁신적인 사항에 대한 내용은 최근 프로그래밍 언어 컨퍼런스에 논문으로 제출되었다.

### 참고

현재의 스칼라 구현은 주로 JVM 위에서 돌아가지만,
어떤 언어 디자인적 선택을 왜 이렇게 했을까하는 문제를 만날 때 가끔은 JVM 과 언어 자체를 분리해서 생각할 필요가 있다.
JVM 에서는 그 구현이 비 효율적인 언어 디자인적 선택을 한 것들이 있는데
이건 엄밀히 말해 언어의 문제가 아니고 JVM, 더 나아가 절차적 컴퓨팅 패러다임 자체의 문제다.
그러니 스칼라를 언어로 바라볼 때 살짝 추상적인 시각에서 접근할 필요가 있다.
