# First Steps, Parameterize Arrays With Types

2011-07-09 00:04


### Parameterize Arrays With Types / 타입을 인자로 어레이을 생성해 보자

스칼라는 new 를 사용해서 클래스 인스턴스, 즉 오브젝트를 생성할 수 있다.
오브젝트는 값이나 타입을 인자로 초기화할 수 있다.

값을 가지고 인스턴스를 초기화하려면 오브젝트들을 () 로 감싸서 생성자에 전달한다.
다음 스칼라 코드는 java.math.BigInteger 인스턴스를 만들고 "12345" 로 초기화한다.

	val big = new java.math.BigInteger("12345")

타입을 가지고 인스턴스를 초기화하려면 타입들을 [ ] 로 감싼다.

	val greetStrings = new Array[String](3)

여기서 greetStrings 는 길이가 3 인 스트링 어레이이다.
인스턴스 초기화시 타입과 값을 모두 전달할 필요가 있다면 [ ], 즉 타입이 먼저 나와야 한다.

보다 명시적인 것을 좋아한다면 다음과 같이 적을 수도 있다.

	val greetStrings: Array[String] = new Array[String](3)

위에서 볼 수 있듯이 타입 인자는 인스턴스 타입의 일부이지만 값 인자는 그렇지 않다.
greetStrings 의 타입은 Array\[String\] 이지 Array\[String\](3) 이 아니다.

어레이의 각 원소들은 다음과 같이 초기화한다.

	greetStrings(0) = "Hello"
	greetStrings(1) = ", "
	greetStrings(2) = "world!\n"

어레이의 각 원소는 ( ) 를 통해 접근한다.
자바에서 처럼 [ ] 가 아니다.

이 예는 스칼라의 val 이 가진 중요한 컨셉도 보여주고 있다.
val 을 가지고 변수를 정의했을 때 변수에 새로운 값을 대입할 수는 없지만
변수가 가리키고 있는 오브젝트 자체는 변경할 수 있다.
greetStrings 변수에 새로운 어레이을 대입할 수는 없지만,
greetStrings 변수가 가리키는 Array\[String\] 오브젝트의 원소들은 바꿀 수 있다.

다음은 어레이의 원소들을 출력하는 코드다.

	for (i <- 0 to 2) print(greetStrings(i))

이것은 for 수식이다.
여기서 0 to 2 구문은 스칼라의 새로운 일반 규칙을 보여준다.
메서드가 인자를 하나만 받는다면 메서드 호출에서 . 와 ( ) 를 생략할 수 있다.
to 는 사실 Int 인자를 받는 메서드다.
종합해 본다면 0 to 2 는 (0).to(2) 라고 볼 수 있다.
단, 이 문법은 메서드 호출을 받는 오브젝트가 명시적으로 존재할 때만 가능하다.
println 10 과 같은 코드는 쓸 수 없다.
Console println 10 은 가능하다.

스칼라는 오퍼레이터 오버로딩 기능이 없다.
전통적인 관점에서의 오퍼레이터 자체가 없다.
대신 +, -, *, / 같은 문자를 메서드 이름에 쓸 수 있다.
1 + 2 를 인터프리터에 입력한다면 실제로는 1 이라는 오브젝트의 + 메서드를 호출하는 것이다. 이때 인자는 2 다.
1 + 2 은 전통적인 메서드 콜 문법으로 (1).+(2) 와 같이 쓸 수 있다.

스칼라의 또 다른 중요한 개념이 이 예제에 나타나 있다.
왜 스칼라는 어레이 원소 접근에 [ ] 대신 ( ) 을 쓸까.
(좀 생소한 개념이니 잘 들어야한다.)

자바에 비해 스칼라에는 특별 케이스라는 것이 거의 없다.
어레이조차 일반적인 클래스의 인스턴스일 뿐이다.
자바처럼 어레이를 위한 특별 문법이 미리 준비되어 있지 않다는 말이다.

스칼라는 변수에 ( ) 를 적용하는 구문을 변수에 apply 메서드를 호출하는 구문으로 변환한다.
greetStrings(i) 라는 구문은 greetStrings.apply(i) 라는 구문으로 변환한다.
그러니 어레이의 원소에 접근하는 것 또한 일반적인 메서드 콜일 뿐이다.
물론 해당 오브젝트의 타입이 apply 메서드를 정의하고 있을 때만 가능하다.

비슷한 방식으로 ( ) 와 적당한 인자를 변수에 적용하고 여기에 대입문까지 붙은 구문은
변수에 대한 update 메서드 콜로 변환하고 여기에 양쪽 인자를 모아 전달한다.

	greetStrings(0) = "Hello"

위 문장은 아래와 같이 변환한다.

	greetStrings.update(0, "Hello")

스칼라는 어레이부터 수식까지 모든 것을 오브젝트로 취급함으로써 개념을 단순화한다.
자바에서 처럼 원시 타입과 래퍼 타입의 차이나, 어레이과 일반 오브젝트의 차이를 외우고 있을 필요가 없다.
게다가 이런 일관성을 달성하기 위해 특별히 성능을 희생하지도 않았다.
스칼라 컴파일러는 최종 컴파일된 코드에 가능한한 자바 어레이이나, 원시 타입, 네이티브 연산자들을 사용한다.

스칼라는 어레이을 초기화하기 위한 좀더 간단한 방법을 제공한다.
아래 코드는 길이가 3 인 스트링 어레이를 생성하고 인자들로 초기화 한다.
전달한 인자가 스트링이기 때문에 컴파일러는 어레이의 타입을 Array\[String\] 으로 추론한다.

	val numNames = Array("zero", "one", "two")

(
new Array\[String](3) 과 달리 위 Array 앞에는 new 가 없는 것을 확인하자.
여기서 Array 는 클래스 명이 아니라 오브젝트명이다. Array 오브젝트의 apply 메서드를 콜하고 있는 것이다.
appy, update 에 new 없는 오브젝트 생성까지, 이쯤되면 짜증이 날 수 있겠다. =,=
)

여태까지 설명한 바에 따라 위 문장에서 실제 이루어지는 일은 Array 라는 오브젝트의 apply 메서드를 호출하는 것이다.
여기에 등장하는 Array 같은 오브젝트를 보조 오브젝트(companion object)라고 부른다.
apply 는 가변적인 수의 인자들을 받아 Array 타입의 인스턴스를 만드는 펙토리 메서드 기능을 한다.

보조 오브젝트(companion object)에 대해서는 4.3 절에서 다시 볼 것이다.
자바 프로그래머라면 위 문장을 Array 클래스의 apply static 메서드를 호출하는 것과 비슷하다고 생각해도 된다.
위 문장을 풀어쓰면 아래와 같다.

val numNames2 = Array.apply("zero", "one", "two")


### 참고

같은 Array 라는 단어가 오브젝트에 쓰였다가 타입에 쓰였다가 머리가 혼란스러울 수 있겠다.
스칼라 라이브러리에는 Array 라는 클래스가 있고, Array 클래스를 보필하는 Array 보조 오브젝트가 있다.
보조 오브젝트는 클래스와 이름이 같고 클래스에 대한 여러가지 도우미 역할을 한다.
Array 보조 오브젝트는 오브젝트지만 array 처럼 소문자로 시작하지 않고 클래스와 이름이 같다.
스칼라에는 static 메서드란 개념이 없기 때문에 자바에서 static 메서드로 하던 일을 컴패니언 오브젝트로 한다고 봐도 좋다.

이런 질문이 떠오를 수 있다.
클래스를 써서 new Array() 로 오브젝트를 만드는 것이 좋을까,
보조 오브젝트를 써서 Array() 로 오브젝트를 만드는 것이 좋을까.
불행히도 편의성과 성능등을 고려해 고민할 점들이 많아 한마디로 쉽게 답하기가 어렵다 =,=

모든 클래스에 대해서 보조 오브젝트가 존재하는 것이 아니라
어떤 경우는 new 구문으로만 오브젝트 생성이 가능하다. =,=

게다가 제 3, 제 4 의 오브젝트 패턴이 있다. =,=

나는 보조 오브젝트를 만들어야할까?
라는 질문이 클래스를 만들 때마다 따라다닐 수 있다. =,=

이런 계륵 같은 것을 왜 만들었을까!
나중에 보면 꽤 대단한 장점들이 나온다.
