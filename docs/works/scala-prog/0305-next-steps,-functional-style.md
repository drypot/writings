# First Steps, Functional Style

2011-07-13 22:59


### Learn to recognize the functional style / F 스타일을 배워보자

스칼라는 절차적 프로그래밍 수단을 제공하긴 하지만 F 스타일 프로그래밍을 더 권장한다.
자바와 같은 절차적 환경에서 작업해 왔다면 F 스타일 프로그래밍을 익히는 것이 스칼라 학습에 있어서 가장 큰 도전이 될 것이다.
F 스타일을 처음 만나는 것이 매우 낮설 수도 있겠지만 새로운 방식에 익숙해질 수 있도록 저자들은 이 책에 많은 노력을 기울였다.

F 스타일 프로그래밍 방식을 습득함으로써 여러분은 보다 훌륭한 스칼라 프로그래머가 될 수 있을 뿐만 아니라
프로그래밍에 대한 시각의 지평을 넓힘으로써 보다 보편적 관점에서 더 나은 프로그래머가 될 것이다.

첫번 째 단계는 두 스타일 간의 차이를 구분하는 것이다.

코드에 var 가 나타나면 그 코드는 절차적일 가능성이 높다.
코드에 val 만 나타나면 그 코드는 F 적일 가능성이 높다.
그러므로 F 스타일 프로그래밍으로 가는 시작은 코드에서 var 를 없애는 것이다.

자바, C++, C# 등의 절차적 환경에서 왔다면 var 를 일반적인 변수로, val 을 변경이 불가능한 특별한 변수로 생각할 것이다.
반대로 Haskell, OCaml, Erlang 등의 F 환경에서 왔다면 val 을 일반적인 변수로, var 를 신성모독으로 치부할 것이다.

스칼라의 관점에선 val, var 가 단지 서로 다른 두 개의 도구일 뿐이다. 둘 다 유용하고 둘 다 절대악이 아니다.
val 의 사용을 독려하긴 하겠지만 스칼라는 주어진 작업을 다루는데 가장 적합한 도구를 제공할 것이다.

스칼라의 균형잡힌 철학에 동의할지라도 var 를 지워나가는 것이 처음부터 쉬운 일은 아닐 것이다.
2 장에서 소개했던 다음 절차적 코드를 보자.

	def printArgs(args: Array[String]): Unit = {
		var i = 0
		while (i < args.length) {
			println(args(i))
			i += 1
		}
	}

var 를 없애고 F 스타일로 바꾼 코드는 아래와 같다.

	def printArgs(args: Array[String]): Unit = {
		for (arg <- args)
			println(arg)
	}

또는 아래와 같다.

	def printArgs(args: Array[String]): Unit = {
		args.foreach(println)
	}

이 예는 var 를 덜 썼을 때의 잇점을 보여준다.
리펙터링된 F 코드는 절자적 코드보다 명확하고, 간결하고, 오류를 만들 소지가 적다.
스칼라가 F 스타일을 권장하는 이유는 F 스타일이 이해하기 쉽고 오류가 적은 코드를 만드는데 도움이 되기 때문이다.

더 나가보자.
리펙터링된 printArgs 메서드는 순수한 F 코드가 아니다.
표준 출력 스트림에 프린팅을 하는 부수효과(side effects)를 가지기고 있기 때문이다.

리턴 타입이 Unit 인 펑션은 부수효과를 갖기 마련이다.
아무런 유용한 값을 리턴하지 않는 펑션이 세상에 먼가 차이를 만드는 유일한 방법은 부수효과를 발생시키는 길 뿐이다.
보다 F 적인 접근 방법은 입력 받은 값을 프린팅을 위해 포멧하고 그냥 이 값을 리턴하는 것이다.

	def formatArgs(args: Array[String]) = args.mkString("\n")

이 코드는 부수효과도 없고 var 도 없다. 진정 펑셔널하다.

mkString 메서드는 어레이, 리스트, 셋, 맵 반복 가능한 모든 컬렉션에 사용할 수 있다.
전달한 스트링 인자를 구분자로 하여 원소의 toString 결과를 모두 연결한 스트링을 리턴한다.

물론 formatArgs 가 결과를 출력하진 않는다.
결과를 출력하려면 다음과 같이 println 을 호출한다.

	println(formatArgs(args))

유용한 모든 프로그램은 어떤 식으로든 부수효과를 갖기 마련이다.
부수효과를 통해서만 프로그램 밖의 세상에 가치를 제공할 수 있기 때문이다.

부수효과가 없는 메서드를 선택하는 것은 부수효과가 최소화된 프로그램을 디자인할 수 있게 한다.
이런 접근방식으로 좀더 테스트하기 쉬운 프로그램을 만들 수 있다.

printArgs 메서드를 테스트하려면 테스트용 println 을 별도로 만들어서 출력을 기록하고 출력이 원하는 결과와 같은지 비교해야했을 것이다.
이와는 반대로 formatArgs 는 그 결과만 확인함으로써 테스트를 마칠 수 있다.

	val res = formatArgs(Array("zero", "one", "two"))
	assert(res == "zero\none\ntwo")

스칼라의 assert 메서드는 전달받은 불린 값이 false 라면 AssertionError 를 던진다.
true 라면 조용히 리턴한다.

이것은 기억해 둬야한다.
var 와 부수효과가 항상 나쁘기만한 것은 아니다.

스칼라는 모든 것을 F 스타일로 프로그램하도록 강제하는 순수 F 언어가 아니다.
하이브리드 절차적/F적 언어다.

어떤 경우에는 절차적 방식이 문제 해결에 더 적합할 수 있다.
그러한 경우에는 절차적 방식을 쓰는 것을 주저하지 말아야한다.

균형잡힌 사고의 스칼라 프로그래머들은 val, 불변 오브젝트, 부수효과가 없는 메서드를 선호한다.
var, 가변 오브젝트, 부수효과는 특별한 필요가 있고 타당한 이유가 있을 때만 사용한다.

7 장에서는 var 형 코드를 val 형 코드로 바꾸는 더 많은 예제를 볼 수 있다.