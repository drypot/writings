# Functional Objects, Part 1

2011-07-18 23:36

### Functional Objects / F 오브젝트

이제 스칼라 클래스 디자인의 풀파워를 느껴보자.
이번 장에서는 (가변 상태를 갖지 않는) F 오브젝트 클래스를 정의하는 방법에 대해 논의한다.
예를 위해 유리수를 모델링하는 불변 오브젝트 클래스의 여러가지 버전을 만들 것이다.
클래스 인자, 클래스 생성자, 메서드와 오퍼레이터, 비공개 멤버, 오버라이딩, 오버로딩, 자기 참조등이 하나 하나 등장한다.


### A specification for class Rational / 유리수 클래스 명세

유리수(Ratinal)란 n/d 와 같이 비율로 표시할 수 있는 수이다.
n 과 d 는 정수이고 d 는 0 이 될 수 없다.
n 은 분자(numberator), d 는 분모(denominator)라 한다.
유리수의 예는 1/2, 2/3, 112/239, 2/1 등.
유리수는 플롯팅 포인트(floating-point)와 달리 반올림이나 근사치를 사용하지 않아 분수를 정확하게 표시할 수 있다.

이 장에서 만들 클래스는 유리수를 모델링하고 사칙연산 기능을 포함한다.

(유리수 연산에 대한 수학적 설명은 생략.)

수학적 관점에서 유리수는 가변 상태를 가질 필요가 없다.
두 개의 유리수를 더하면 새로운 유리수가 만들어진다.
처음 수들은 변하지 않는다.
이번 장에서 디자인할 불변 유리수 클래스는 수학적 유리수와 같은 성질을 갖는다.
각 유리수는 하나의 유리수 오브젝트로 표현된다.
두 유리수 오브젝트를 더하면 새로운 유리수 오브젝트를 생성한다.
라이브러리를 언어가 처음부터 지원하는 것처럼 보이도록 만드는 방법도 함께 볼 것이다.

이 장의 마지막에서 얻게될 유리수 클래스의 용법을 미리 보면 아래와 같다.

	scala> val oneHalf = new Rational(1, 2)
	oneHalf: Rational = 1/2
	scala> val twoThirds = new Rational(2, 3)
	twoThirds: Rational = 2/3
	scala> (oneHalf / 7) + (1 - twoThirds)
	res0: Rational = 17/42


### Constructing a Rational / 유리수 틀짜기

유리수 클래스 디자인을 시작하는 적합한 지점은
클라이언트 프로그래머들이 유리수 오브젝트를 어떻게 생성할지를 생각해 보는 것이다.
유리수 오브젝트가 불변성을 갖도록 만들기로 했으니
클라이언트가 오브젝트 생성에 필요한 데이터를 오브젝트 생성시 모두 제공해야 한다.
유리수의 경우에는 분자와 분모가 되겠다.
다음 코드로 디자인을 시작한다.

	class Rational(n: Int, d: Int)

이 코드는 자체로 완전하다.
문제 없이 컴파일된다.

클래스 몸체가 없으면 클래스 몸체를 감싸는 { } 을 생략할 수 있다.
클래스 이름은 Rational 이다.
클래스 이름 다음에 나오는 ( ) 와 n, d 인자는 클래스 인자라고 한다.
기본 생성자는 스칼라 컴파일러가 만들고 클래스 인자와 같은 인자들을 받는다.

자바에는 생성자가 있고 생성자가 인자를 받는다.
하지만 스칼라에서는 클래스가 직접 인자를 받는다.
스칼라 표현법이 더 간단하다.
클래스 인자는 클래스 몸체에서 바로 사용될 수 있다.
필드를 정의하고 생성자가 받은 인자를 필드로 복사하는 코드를 만들 필요가 없다.
클래스 인자는 특히 작은 클래스에서 불필요하게 반복되는 코드를 대폭 줄인다.

클래스 몸체에 나오는 코드중 필드와 메서드 정의의 외의 코드들은 기본 생성자의 일부가 된다.

	class Rational(n: Int, d: Int) {
		println("Created "+ n +"/"+ d)
	}

위 코드에서 println 구문은 기본 생성자로 들어간다.
Rational 인스턴스를 만들 때마다 println 구문이 실행된다.

	scala> new Rational(1, 2)
	Created 1/2
	res0: Rational = Rational@90110a

### 참고
여러분이 역자과 같다면 초반부터 큰 충격을 받았을 것이다.
이게 다 모야! 다 싫어!

하지만 조금만 익숙해 지면 C++, Java 의 번잡함이 얼마나 우리를 괴롭혀 왔는지 깨닫게 될 것이고
스칼라 방식을 정말정말 사랑하게 될 수 있다.

앞으로 많은 예를 보겠지만 클래스 인자로 생성자를 없애 버리면서
클래스 바디에 필드 정의와 생성자 코드를 군데 군데 늘어놓을 수 있다는 것은 엄청난 잇점을 가진다.
필드를 추가하고 수정할 때마다 필드, 생성자, getter/setter 를 왔다갔다할 필요가 사라진다.



### Immutable object trade-offs / 불변 오브젝트의 장점과 단점

불변 오브젝트는 가변 오브젝트와 비교해 몇 가지 장점과 한 가지 잠재적인 단점을 가진다.

불변 오브젝트는 시간이 지남에 따라 상태가 변하는 복잡함이 없기 때문에 가변 오브젝트 보다 이해하기 쉽다.
불변 오브젝트는 매우 자유롭게 전달할 수 있다.
가변 오브젝트의 경우에는 다른 코드에 보낼 때 방어적 코딩을 위해 오브젝트의 복제를 만들어야 한다.
불변 오브젝트는 두 스레드가 동시에 사용하더라도 상태 이상이 발생하지 않는다.
불변 오브젝트의 해쉬 테이블 키는 안전하다.
가변 오브젝트를 HashSet 에 넣은 후에 내용을 변경하면 HashSet 에서 다시 찾을 수 없게 된다.

불변 오브젝트의 최대 단점은 간혹 매우 큰 오브젝트 그래프를 복제해야 한다는 점이다.
가변 오브젝트였다면 그 자리에서 간단히 변경할 수 있었을 것이다.
경우에 따라 이 문제는 표현하기 난감하기도 하고 성능에 큰 문제가 될 수도 있다.
그래서 많은 라이브러리가 불변 오브젝트에 대한 대안들을 함께 제공한다.
가변 StringBuilder 는 불변 String 에 대한 대안이다.
가변 오브젝트를 디자인하는 법에 대해서는 18 장에서 더 살펴본다.


### Reimplementing the toString method / toString 메서드 구현

Rational 의 인스턴스를 만들었을 때 인터프리터는 "Rational@90110a" 를 출력했다.
인터프리터는 이 스트링을 Rational 오브젝트의 toString 으로 부터 얻는다.
Rational 클래스는 java.lang.Object 의 toString 구현을 계승한다.
toString 의 결과는 디버깅 출력, 로그 메시지, 테스트 실패 레포트, 인터프리터나 디버거 아웃풋등 개발시 유용하게 사용된다.

Rational 의 toString 에 의해 현재 제공되는 정보는 유리수 값과 거의 관련이 없기 때문에 별로 유용하지 않다.
유용한 toString 이라면 분자와 분모의 값을 보여줄 수 있어야 한다.

	class Rational(n: Int, d: Int) {
		override def toString = n + "/" + d
	}

override 수정자는 슈퍼클래스에 정의된 메서드를 오버라이딩하고 있음을 나타낸다.
이에 대해서는 10 장에서 다시 설명한다.

Rational 의 숫자들이 제대로 출력되므로 이전 버전에서 클래스 몸체에 넣었던 디버깅용 println 문장을 삭제했다.
인터프리터에서 새 Rational 의 기능을 테스트해볼 수 있다.

	scala> val x = new Rational(1, 3)
	x: Rational = 1/3
	scala> val y = new Rational(5, 7)
	y: Rational = 5/7


### Checking preconditions / 전제조건

유리수 분모는 0 이 될 수 없다.
하지만 현재는,,,

	scala> new Rational(5, 0)
	res1: Rational = 5/0

OOP 의 장점중 하나는 데이타를 오브젝트로 감싸서 오브젝트의 일생동안 유효한 값을 유지할 수 있다는 것이다.
Rational 과 같은 불변 오브젝트의 경우에는 오브젝트를 생성할 때 데이타가 유효한지 확인해야 한다.
d 인자로 0 이 오면 Rational 은 생성될 수 없다.

이 문제에 대한 가장 좋은 접근법은 d 는 0 일 수 없다는 기본 생성자의 전제조건(precondition)을 정의하는 것이다.
전제조건은 메서드나 생성자에 전달된 인자에 대한 제약이다.
호출하는 측은 이 요구사항을 만족시켜야 한다.

	class Rational(n: Int, d: Int) {
		require(d != 0)
		override def toString = n +"/"+ d
	}

require 메서드는 boolean 인자를 받는다.
인자가 참이라면 아무일 없이 리턴한다.
거짓이라면 IllegalArgumentException 을 던진다.