---
title: Commit
---

### 인덱스

`.git/index` 에 인덱스가 있다. 
워킹디렉토리 상태, 리포지터리 상태, 커밋할 상태의 차이를 관리하기 위해 사용한다.
커밋시 워킹 디렉토리가 몽땅 리포지터리로 들어가지 않는다.
수정한 파일이 자동으로 들어가는 것도 아니다.
수정된 파일 중 그것도 인덱스에 등록된 파일만 다음 커밋의 대상이 된다.

줄거리는 이렇다.

* 리포지터리를 새로 만들면 비어있다.
* 워킹 디렉토리에 파일 몇 개를 추가한다.
* 새로 만든 파일은 아직 인덱스에 등록되지 않았으므로 Git 의 관리 대상이 아니다.
* git add 명령으로 파일들을 인덱스에 등록한다.
* git add 시 파일 자체는 리포지터리에 미리 들어가지만 커밋이 만들어지지 않았으므로 고아상태이다. 인덱스만 알고 있다.
* git commit 명령으로 커밋 오브젝트를 생성한다. 새 스냅샷이 저장되었다.
* 몇몇 파일을 수정하거나 삭제하거나 새로 추가하거나 이동한다.
* 다음 커밋에 기록하고 싶은 추가, 삭제 내용을 git add/rm 으로 등록한다.
* git commit 으로 새 스냅샷을 저장한다.

파일을 새로 만들거나 수정할 때마다 인덱스에 추가하는 일은 매우 성가실 듯한데
실전에선 GUI 나 IDE 가 수정한 파일들을 등록해준다.

코멘드라인에서는 `git add .` 으로 수정 내용을 한방에 등록할 수 있다.


### git add

커밋하려면 파일을 인덱스에 add 해야 한다.
커밋 후 수정한 파일을 다시 커밋하려면 다시 add 해야한다.
이 작업을 스테이징이라 한다.

커밋하려는 파일을 인덱스에 등록한다.

    $ git add readme.md

특정 서브 디렉토리의 전체를 스테이징할 수 있다.

    $ git add src

add 했던 파일을 인덱스에서 삭제한다. 워킹 디렉토리에서도 삭제한다.

    $ git rm tmp.txt

add 했던 파일을 인덱스에서 삭제하지만. 워킹 디렉토리는 건들지 않는다.

    $ git rm —cached tmp.txt

파일별로 일일이 기록하려면 귀찮다. 변동 내용을 한번에 인덱싱할 수 있다. 새로 추가한 화일은 제외된다.

    $ git add -u

새로 추가한 파일까지 한번에 인덱싱할 수 있다.

    $ git add .

결론, 커밋 전에 'git add .' 명령으로 인덱스를 일괄 업데이트 한다.


### git status

인덱스의 상태를 확인할 수 있다. 워킹디렉토리 변동 상태, 다음에 커밋할 내용.

    $ git status

축약 버전.

    $ git status -s

인덱스가 관리하고 있는 파일 목록을 볼 수 있다.

    $ git ls-files -s


### git commit

리포지터리에 새로운 커밋 파일을 만든다. (= 스냅샷을 저장한다.)
다음에 이 상태로 돌아올 수 있다.
`-m` 옵션은 필수다.

    $ git commit -m "first commit"

수정된 파일들의 인덱싱과 커밋을 한번에 할 수 있다.
새로 생성한 파일은 자동 등록되지 않는다.

    $ git commit -a -m "commit all modified"

활용성 떨어짐. 걍 'git add .' 을 쓰자.

바로 이전 커밋에 변동 내용을 추가할 수 있다.

    $ git commit --amend


### git log

커밋 히스토리를 보여준다.

    $ git log
    $ git log --pretty=oneline
    $ git log --oneline
    $ git log -5


### git log search

커밋 메시지를 검색

    $ git log --grep="commit contents"

수정된 코드를 검색

    $ git log -S"diff contents"

수정된 파일을 검색

    $ git log -- path/or/file


{:class="go-to-index"}
[Git ABC](index)
